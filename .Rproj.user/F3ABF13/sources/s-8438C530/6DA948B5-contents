# Script to look at the squid FA data and sort out transformations


# Get squid data in -------------------------------------------------------

# Script for reading in and analyzing data for Ovens

# All this sourcing should eventually be dealt with by making it a package/library
library(here)
source(here('fwFunctions.R'))
#source(here('dataorg', 'ovensparser.R'))
#source(here('dataorg', 'lakesparser.R'))
#source(here('dataorg', 'gwydirparser.R'))
#source(here('dataorg', 'kellerparser.R'))
source(here('dataorg', 'squidparser.R'))
source(here('dataorg', 'groupstandard.R'))
source(here('dataorg', 'fasiparser.R'))
source(here('dataorg', 'fasicombine.R'))
source(here('dataorg', 'jointfasipca.R'))
source(here('dataorg', 'fasianalyze.R'))
source(here('dataorg', 'PCAanalyze.R'))
source(here('dataorg', 'datasaver.R'))

## TODO: Think about making this a function that can be called by the MixSIAR prep stuff.
# I think it's a bad idea, but noting here for future. THe thought is we could have a
# dataprep script there that calls this and passes the directory name.
# But We'll want to change a LOT of things for each run though, so we'd need separate
# 'functions' for each. Which at that point are effectively scripts, and so better to
# either run them separately, or 'source' them, rather than making them funcitons.
# E.g. they are specific processing pathways, not robust, general things and so are
# better thought of as scripts than functions

# which datasets?
datanames <- c('squid')

# set an analysis directory (if desired)
# can be done on an individual function call basis too
thisDir <- 'squid'
if (!dir.exists(paste0(fasiOutDir, '/', thisDir))) {dir.create(paste0(fasiOutDir, '/', thisDir))}

# parse and return a list of SI, FA, and FAW (and possibly the sep --------
# Datasets are bound together with bind_rows, but otherwise very light processing in the join
fasilist <- fasiparser(datanames, returnSeparate = FALSE)


# First, look just at the FA ----------------------------------------------

# what's in the data
unique(fasilist$allFA$group)

# Get the prey
# and no mullet because it's not always there
preyFAs <- subset(fasilist$allFA, trophic != 'squid' & group != 'StripedMullet')
unique(preyFAs$group)

# Get the pred
predFAs <- subset(fasilist$allFA, trophic == 'squid')
# Now group is the treatment
# Cut to just the shrimp diet for the purposes of looking at FA distributions and transformations
predFAshrimp <- subset(predFAs, group == 'C')

# Now, I think I actually want the preds and preys together for the transforms etc, so
# Which means I could have done this all in one subset, but oh well
allFAs <- bind_rows(preyFAs, predFAshrimp)

# Just pull out the groups we need
allSimple <- select(allFAs, group, starts_with('fa'))

# Fix the zeros
minVal <- allSimple %>% select(where(is.numeric))
minVal <- min(minVal[minVal != 0])
allSimple[allSimple == 0] <- minVal * 0.1


# The things to look at ---------------------------------------------------

## Using Neubauer's FAs
faNeub <- c('fa22.6n_3', 'fa20.5n_3', 'fa20.4n_6', 'fa18.1n_9')

# The distributions of the FAs themselves
# pairwise plots, colored by group. Or boxplots. Or something
# The alr() transforms
# The ilr() transforms
# The transforms with "other" added in as a column
# Check that myPCA(ilr(data)) yields the same thing as pcaCoDa from
# robCompositions, (and how is that affected by back-transforms?)

cutNeuFA <- select(allFAs, group, all_of(faNeub))

# Make an 'other' column too, will need it later, and should probably plot now
# 100 minus because in percents
cutNeuFA <- mutate(cutNeuFA, other = 100-(fa22.6n_3 + fa20.5n_3 + fa20.4n_6 + fa18.1n_9))
# What's the best way to look at the distributions?
ggplot(cutNeuFA, aes(x = fa22.6n_3, y = fa20.5n_3, color = group, shape = (group == 'C'))) + geom_point()
# Can I index with numbers?

faplus <- names(cutNeuFA)[2:length(names(cutNeuFA))]
# Takes a while. Comment out for now
# for (i in 1:length(faplus)) {
#   for (j in 1:length(faplus)) {
#     print(ggplot(cutNeuFA, aes_string(x = faplus[i], y = faplus[j], color = 'group')) + geom_point())
#   }
# }

# Meh. go with the boxplot method, I think it's clearer for the multiple comparisons
# or, actaully, probably violins with overlain points
# SO... I THINK THAT MEANS I NEED THE DATA TO BE TALL so the FA's can be factors
# Which will have to happen several times, since the transforms need the rows
cutNeuStack <- pivot_longer(cutNeuFA, -group, names_to = 'FA', values_to = 'percent')
ggplot(cutNeuStack, aes(x = FA, y = percent, color = group)) + geom_violin()
ggplot(cutNeuStack, aes(x = FA, y = percent, color = group)) + geom_boxplot()


# All the FAs -------------------------------------------------------------
  # Kind of hard to see what happens here

allStack <- pivot_longer(allSimple, -group, names_to = 'FA', values_to = 'percent')
ggplot(allStack, aes(x = FA, y = percent, color = group)) + geom_boxplot()



# Logit transform ---------------------------------------------------------
cutNeuProp <- cutNeuFA %>% mutate_if(is.numeric, ~./100)
logitNeu <- mutate_if(cutNeuProp, is.numeric, logit)
logitStack <- pivot_longer(logitNeu, -group, names_to = 'FA', values_to = 'logitProportion')
ggplot(logitStack, aes(x = FA, y = logitProportion, color = group)) + geom_boxplot()
ggplot(logitStack, aes(x = FA, y = logitProportion, color = group)) + geom_violin()
  # That's a bit better than straight up, but does nothing about the compositional issues


# alr transform -----------------------------------------------------------
library(robCompositions)
?addLR

# With "other" to make truly compositional
alrOther <- addLR(cutNeuProp[ ,2:ncol(cutNeuProp)])
alrOther2 <- bind_cols(group = cutNeuProp$group, alrOther$x.alr)
alrOtherStack <- pivot_longer(alrOther2, -group, names_to = 'FA', values_to = 'alr')

# Without "other"
alrFAonly <- addLR(cutNeuProp[ ,2:(ncol(cutNeuProp)-1)])
alrFAonly2 <- bind_cols(group = cutNeuProp$group, alrFAonly$x.alr)
alrFAonlyStack <- pivot_longer(alrFAonly2, -group, names_to = 'FA', values_to = 'alr')

# with Neubauer's clo() function to make the cut still add to 1
clo <- function(x){
  
  if (is.null(dim(x))){xc <- x/sum(x)} else {xc <- t(apply(x,1,function(y){y/sum(y)}))}
  return(xc)
}

alrFAclo <- addLR(clo(cutNeuProp[ ,2:(ncol(cutNeuProp)-1)]))
alrFAclo2 <- bind_cols(group = cutNeuProp$group, alrFAclo$x.alr)
alrFAcloStack <- pivot_longer(alrFAclo2, -group, names_to = 'FA', values_to = 'alr')

ggplot(alrOtherStack, aes(x = FA, y = alr, color = group)) + geom_boxplot()
ggplot(alrFAonlyStack, aes(x = FA, y = alr, color = group)) + geom_boxplot()
ggplot(alrFAcloStack, aes(x = FA, y = alr, color = group)) + geom_boxplot()


# NOW SAME WITH ILR -------------------------------------------------------
?isomLR
# apparently deprecated, use pivotCoord

# With "other" to make truly compositional
ilrOther <- pivotCoord(cutNeuProp[ ,2:ncol(cutNeuProp)])
ilrOther2 <- bind_cols(group = cutNeuProp$group, ilrOther)
ilrOtherStack <- pivot_longer(ilrOther2, -group, names_to = 'FA', values_to = 'ilr')

# Without "other"
ilrFAonly <- pivotCoord(cutNeuProp[ ,2:(ncol(cutNeuProp)-1)])
ilrFAonly2 <- bind_cols(group = cutNeuProp$group, ilrFAonly)
ilrFAonlyStack <- pivot_longer(ilrFAonly2, -group, names_to = 'FA', values_to = 'ilr')

# Closured
ilrFAclo <- pivotCoord(clo(cutNeuProp[ ,2:(ncol(cutNeuProp)-1)]))
ilrFAclo2 <- bind_cols(group = cutNeuProp$group, ilrFAclo)
ilrFAcloStack <- pivot_longer(ilrFAclo2, -group, names_to = 'FA', values_to = 'ilr')

ggplot(ilrOtherStack, aes(x = FA, y = ilr, color = group)) + geom_boxplot()
ggplot(ilrFAonlyStack, aes(x = FA, y = ilr, color = group)) + geom_boxplot()
ggplot(ilrFAcloStack, aes(x = FA, y = ilr, color = group)) + geom_boxplot()


# What are some comparisons between methods -------------------------------
# Can't really facet because variables differ
alrplot <- ggplot(alrOtherStack, aes(x = FA, y = alr, color = group)) + geom_boxplot()
ilrplot <- ggplot(ilrOtherStack, aes(x = FA, y = ilr, color = group)) + geom_boxplot()
dataplot <- ggplot(cutNeuStack, aes(x = FA, y = percent, color = group)) + geom_boxplot()
logitplot <- ggplot(logitStack, aes(x = FA, y = logitProportion, color = group)) + geom_boxplot()

egg::ggarrange(dataplot, logitplot, alrplot, ilrplot)


# Trying to do a PCA ------------------------------------------------------
  # LEAVE OTHER IN; I think it's more appropriate
# use pcaCoDa directly
?pcaCoDa()

codaPC <- pcaCoDa(cutNeuProp[ ,2:(ncol(cutNeuProp))], method = 'classical')
biplot(codaPC)

# do a regular PCA on the ilr transforms
pcaILR <- PCA(ilrOther, scale.unit = FALSE)
fviz_pca_biplot(pcaILR)

# So, that matches (nearly), if use classical for pcaCoDa, and don't scale in PCA.
# Not scaling is likely because the data has been transformed, and so is likely the way to go. But 
#### TODO: HOW DOES PCACODA handle other non-compositional variables? I'll need to sort that out.

# With all the FA
allProp <- allSimple %>% mutate_if(is.numeric, ~./100)

# do a regular PCA on the ilr transforms
ilrAll <- pivotCoord(allProp[ ,2:ncol(allProp)])
pcaILRAll <- PCA(ilrAll, scale.unit = FALSE)
fviz_pca_biplot(pcaILRAll)

# And the coda
codaPCAll <- pcaCoDa(allProp[ ,2:(ncol(allProp))], method = 'classical')
biplot(codaPCAll)

# CHECK
codaPCAll$scores[1:20, 1:5]
pcaILRAll$ind$coord[1:20,]

# Awesome! Now, to sort out how to deal with non-compositional data in the PCA, and how to incorporate it if I'm building from cov matrices?
## TODO: Cov matrices including non-compositional data
