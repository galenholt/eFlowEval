---
title: "Local Metabolism Plots"
output: html
editor: 
  markdown: 
    wrap: 72
---

```{r setup}
#| label = "setup"
# set the root to the project directory, not the rmd directory
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
# default to not printing the code
knitr::opts_chunk$set(echo = FALSE)

# libraries
library(tidyverse)
library(sf)
library(stars)
library(tmap)
library(transformr) # not needed for this doc at present?
library(gganimate) # not needed here at present
library(viridis)
library(colorspace)
library(patchwork)
library(latex2exp)
```

```{r}
#| message = FALSE
# source in the data management

# Kind of hacky check to only run if needed
if (!('weraiCropInun' %in% ls())) {
    source(file.path(here::here(), 'Scripts', 'plotting', 'metabPlotSetup_Local.R'))
}

```

Purpose here is primarily to go through some plots, look at them, and
make static versions for the paper. This is mostly a copy-paste and
translate over from metabolismLocalAndStatic. I've done this to split
out the data read-in, function definitions, and plotting (and
particularly the plot trying-out). I've been using these notebooks for
plot testing, because it's really nice to be able to scroll around and
see what we've done, rather than have to keep re-making plot objects
when we forget what they look like.

*The catch with this approach is the quick and dirty prototyping isn't
quite so quick, and this document ends up taking FOREVER to load.* Might
switch back? But it sure is nice to actually see what each figure I made
looks like, especially when we're likely to drop this for extended
periods.

Set the date for examples

```{r}
availDays <- st_get_dimension_values(weraiCropTemp, which = 'time')
datewanted <- as.character(availDays[18])
```

## Static versions with drivers and outcomes

Make a static version using the tmap functions

```{r}
suppressMessages(tmap_mode('plot'))

# allfun(tempObj = weraiCropTemp, tempAtt = 1,
#                    inunObj = weraiCropInun, inunAtt = 1,
#                    gppObj = weraiCropPredGPP, gppAtt = 1,
#                    erObj = weraiCropPredER, erAtt = 1,
#                    datewanted)

```

Clean that up just a bit, with a grey background. probably pull the
title off but it's nice to have as reference while i'm making these

```{r}
tm_grid_static <- tmap_arrange(tempfun(weraiCropTemp, 1, datewanted) +
                                 tm_layout(bg.color = "grey85"),
                               inunfun(weraiCropInun, 1, datewanted, titled = FALSE) +
                                 tm_layout(bg.color = "grey85"),
                               gppfun(weraiCropPredGPP, 1, datewanted, titled = FALSE) +
                                 tm_layout(bg.color = "grey85"),
                               erfun(weraiCropPredER, 1, datewanted, titled = FALSE) +
                                 tm_layout(bg.color = "grey85"))
tm_grid_static
```

I think for completeness let's make a ggplot version too and see which
is better. Takes more work, but have more control (probably just because
I speak ggplot)

```{r}
gg_grid_static <- ggpubr::ggarrange(
  tempfun(weraiCropTemp, 1, datewanted, titled = FALSE,
          titlePrefix = 'Two months preceding ', plotPkg = 'ggplot') + 
    guides(fill = guide_legend(title.position = 'top')) +
    theme_pub() +
    theme(legend.position = 'bottom', 
          legend.background = element_blank(),
          legend.key.size = unit(0.3, 'cm')),
  inunfun(weraiCropInun, 1, datewanted, titled = FALSE, plotPkg = 'ggplot') + 
    guides(fill = guide_legend(title.position = 'top')) +
    theme_pub() +
    theme(legend.position = 'bottom', 
          legend.background = element_blank(),
          legend.key.size = unit(0.3, 'cm')),
  gppfun(weraiCropPredGPP, 1, datewanted, titled = FALSE, plotPkg = 'ggplot') + 
    guides(fill = guide_legend(title.position = 'top')) +
    theme_pub() +
    theme(legend.position = 'bottom', 
          legend.background = element_blank(),
          legend.key.size = unit(0.3, 'cm')),
  erfun(weraiCropPredER, 1, datewanted, titled = FALSE, plotPkg = 'ggplot') + 
    guides(fill = guide_legend(title.position = 'top')) +
    theme_pub() +
    theme(legend.position = 'bottom', 
          legend.background = element_blank(),
          legend.key.size = unit(0.3, 'cm')),
  ncol = 2, nrow = 2)
print(gg_grid_static)

```

Code block to print and make those into figs

```{r}
pdf(file.path(scriptOut, 'Werai_tm.pdf'), 
    onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
print(tm_grid_static)
dev.off()

png(file.path(scriptOut, 'Werai_tm.png'), 
    height = 12/2.54, width = 16/2.54, units = 'in', res = 300)
print(tm_grid_static)
dev.off()

# Can I print those?
# pdf(file.path(scriptOut, 'Werai_gg.pdf'), 
#     onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
# print(gg_grid_static)
# dev.off()
# 
# png(file.path(scriptOut, 'Werai_gg.png'), 
#     height = 12/2.54, width = 16/2.54, units = 'in', res = 300)
# print(gg_grid_static)
# dev.off()

ggsave(file.path(scriptOut, 'Werai_gg.pdf'),
       plot = gg_grid_static,
       height = 12, width = 16, units = 'cm')

ggsave(file.path(scriptOut, 'Werai_gg.png'), 
       plot = gg_grid_static,
    height = 12, width = 16, units = 'cm')
```

## Uncertainty

I think now that I have the functions, there's a slicker way to do this,
but I don't want to reinvent the wheel at this point. Might want to turn
this into a function?

### ER

```{r}
# ER
er_sf <- weraiCropPredER[1,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(ER = 1) %>%
  mutate(logER = log10(1+ER), type = 'estimate')
er_sfPU <- weraiCropPredER[2,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(ER = 1) %>%
  mutate(logER = log10(1+ER), type = 'upper')
er_sfPL <- weraiCropPredER[3,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(ER = 1) %>%
  mutate(logER = log10(1+ER), type = 'lower')

er_sf_LMU <- bind_rows(er_sf, er_sfPU, er_sfPL) %>%
  mutate(namedPI = ifelse(type == 'lower', "Lower 95% PI",
                          ifelse(type == 'estimate', "Estimate",
                                 ifelse(type == 'upper', "Upper 95% PI", 
                                        'SCREWUP'))))

erlabel <- 'ER (kg 02/day)\nat max extent'

# Can get away with this because pretty ranges work out OK
erControl <- ersetup(data = weraiCropPredER, attnum = 1)

  er_gg_uncertain <- ggplot() +
    geom_sf(data = er_sf_LMU, mapping = aes(fill = logER), color = NA) +
    # geom_sf_label(data = ltimNoNorth, mapping = aes(label = ValleyName)) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = erControl$erpal,
                      breaks = erControl$erbreaks[2:length(erControl$erbreaks)],
                      limits = c(min(erControl$erbreaks), max(erControl$erbreaks)),
                      labels = erControl$erlabels,
                      guide = 'legend',
                      name = erlabel) +
    facet_grid(fct_reorder(namedPI, .x = logER, .fun = max)~.) # lower, estimat and upper should always fall in that order for their maxes

er_gg_uncertain

```

### GPP

```{r}


# GPP
# I'm sure there's a slick way to select all three attributes and do this in one
# go, but I just need to get this done
gpp_sf <- weraiCropPredGPP[1,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(GPP = 1) %>%
  mutate(logGPP = log10(1+GPP), type = 'estimate')
gpp_sfPU <- weraiCropPredGPP[2,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(GPP = 1) %>%
  mutate(logGPP = log10(1+GPP), type = 'upper')
gpp_sfPL <- weraiCropPredGPP[3,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(GPP = 1) %>%
  mutate(logGPP = log10(1+GPP), type = 'lower')

gpp_sf_LMU <- bind_rows(gpp_sf, gpp_sfPU, gpp_sfPL) %>%
  mutate(namedPI = ifelse(type == 'lower', "Lower 95% PI",
                          ifelse(type == 'estimate', "Estimate",
                                 ifelse(type == 'upper', "Upper 95% PI", 
                                        'SCREWUP'))))

gpplabel <- 'GPP (kg 02/day)\nat max extent'

gppControl <- gppsetup(weraiCropPredGPP, attnum  = 1)

gpp_gg_uncertain <- ggplot() +
  geom_sf(data = gpp_sf_LMU, mapping = aes(fill = logGPP), color = NA) +
  # geom_sf_label(data = ltimNoNorth, mapping = aes(label = ValleyName)) +
  coord_sf() +
  # Closest to the tmap
  scale_fill_stepsn(colors = gppControl$gpppal,
                    breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                    limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                    labels = gppControl$gpplabels,
                    guide = 'legend',
                    name = gpplabel) +
  facet_grid(fct_reorder(namedPI, .x = logGPP, .fun = max)~.) # lower, estimat and uppgpp should always fall in that ordgpp for their maxes

gpp_gg_uncertain
```

Combine the ER and GPP and save as figures

```{r}
both_uncertain <- ggpubr::ggarrange(gpp_gg_uncertain + 
                                   guides(fill = guide_legend(title.position = 'top')) +
                                   theme_pub() +
                                   theme(legend.position = 'bottom', 
                                         legend.background = element_blank(),
                                         legend.key.size = unit(0.3, 'cm')), 
                                 er_gg_uncertain + 
                                   guides(fill = guide_legend(title.position = 'top')) +
                                   theme_pub() +
                                   theme(legend.position = 'bottom', 
                                         legend.background = element_blank(),
                                         legend.key.size = unit(0.3, 'cm')),
                                 ncol = 2, nrow = 1)
both_uncertain

# Just print the ggplots
# Can I print those?
pdf(file.path(scriptOut, 'Werai_uncertainty.pdf'), 
    onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
print(both_uncertain)
dev.off()

png(file.path(scriptOut, 'Werai_uncertainty.png'), 
    height = 12/2.54, width = 16/2.54, units = 'in', res = 300, type = 'cairo')
print(both_uncertain)
dev.off()




```

## Bar charts

Make a wide version of the data so I can have mins and maxes OR, should
I do all of them and fct_order them?

Joining seems safe, but geographic joins are a mess. It doesn't work at
all. binding cols is actually safer and works

### GPP

```{r}
# Get the inundation to glue on too
inun_sf <- weraiCropInun[1,,] %>% 
  st_as_sf() %>% 
  select(all_of(datewanted)) %>%
  rename(inun = 1) %>%
  mutate(logInun = log10(1+inun))

gpp_sf_LMU_wide <- bind_cols(gpp_sf[,-4], 
                           st_drop_geometry(rename(gpp_sfPU[,-c(4)], 
                                  UGPP = GPP, 
                                  upper_logGPP = logGPP)),
                           st_drop_geometry(rename(gpp_sfPL[,-4], 
                                  LGPP = GPP,
                                  lower_logGPP = logGPP)),
                           st_drop_geometry(inun_sf)) %>%
  
  mutate(wetlandID = row_number())
```

Maybe for a subset of wetlands?

```{r}
# Grab some set of wetlands
which(gpp_sf$geometry == gpp_sf_LMU$geometry[3])
exampleWets <- c(1:100)
```

```{r}
bargpp <- ggplot(gpp_sf_LMU_wide[exampleWets, ], 
                 aes(x = wetlandID, y = logGPP, fill = logGPP)) +
  geom_col() + # the geom_bar equivalent when it's not counting cases.
  geom_linerange(mapping = aes(ymin = lower_logGPP, ymax = upper_logGPP), color = 'grey50') +
  scale_fill_stepsn(colors = gppControl$gpppal,
                    breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                    limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                    labels = gppControl$gpplabels,
                    guide = 'legend',
                    name = gpplabel) +
  scale_y_continuous(breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     labels = round(10^(gppControl$gppbreaks[2:length(gppControl$gppbreaks)]))) +
  labs(x = 'Wetland', y = gpplabel)
bargpp

```

```{r}
pdf(file.path(scriptOut, 'FewGPPbars.pdf'), 
    onefile = FALSE, height = 8/2.54, width = 12/2.54, useDingbats = FALSE)
print(bargpp)
dev.off()

png(file.path(scriptOut, 'FewGPPbars.png'), 
    height = 8/2.54, width = 12/2.54, units = 'in', res = 300)
print(bargpp)
dev.off()
```

I assume it is a mess to just throw them all on actually, with a fair
amount of monkeying with the look, that's OK

```{r}
# Get x breaks that exist when discretized
breakswanted <- c(0, 1, 10, 100, 1000)
xbreaks <- foreach(b = breakswanted, .combine = c) %dopar% {
    gpp_sf_LMU_wide$inun[which.min(abs(gpp_sf_LMU_wide$inun - b))]
} 

bargppall <- ggplot(gpp_sf_LMU_wide, 
                 aes(x = fct_rev(as.factor(inun)), # fct_reorder(as.factor(wetlandID), inun, .desc = TRUE), 
                     y = logGPP, fill = logGPP)) +
  geom_col() + # the geom_bar equivalent when it's not counting cases.
  geom_linerange(mapping = aes(ymin = lower_logGPP, ymax = upper_logGPP),
                 color = 'grey50', alpha = 0.2) +
  scale_fill_stepsn(colors = gppControl$gpppal,
                    breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                    limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                    labels = gppControl$gpplabels,
                    guide = 'legend',
                    name = gpplabel) +
  scale_y_continuous(breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     labels = round(10^(gppControl$gppbreaks[2:length(gppControl$gppbreaks)]))) +
  scale_x_discrete(breaks = as.character(xbreaks), labels = as.character(round(xbreaks))) +
  labs(y = gpplabel, x = 'Inundation volume (Ml at max extent)')
bargppall
```

Those breaks are really tough to sort out.

I actually like that that encompasses an area that integrates to total
production across the Werai

\*Aside- why do the errors look smaller when I aggregate to catchment
scale in the \_Basin plot doc?\*

I should be able to look at that by summing here- I think it has to do
with the logging, but I want to make sure.

The way to do this to match is add up the non-logged, then log the
outcome. That way I'm adding arithmetically, not goofing up and
mulitplying

```{r}
gppsum <- gpp_sf_LMU_wide %>%
  st_drop_geometry() %>%
  summarise(GPP = sum(GPP, na.rm = TRUE), 
            UGPP = sum(UGPP, na.rm = TRUE), 
            LGPP = sum(LGPP, na.rm = TRUE))

# this is going to be silly because just one bar
ggplot(gppsum, aes(x = 'werai', y = log10(GPP + 1))) +
  geom_col() + 
  geom_linerange(mapping = aes(ymin = log10(LGPP + 1), ymax = log10(UGPP + 1)),
                 color = 'black')
  
```

So, that does look roughly like what I'm getting for the catchment
aggregations. I have done the local errors correctly (ie on the linear
scale, then logged), (see gpp_sPU creation above). So this is the
consequence of the errors looking relatively smaller as they're combined
and on the log scale.

I can do points as below, but the integration implied above is nice.

This actually looks better if I plot it against inundation (or log
inundation) as a continuous variable

```{r}
bargppallpoint <- ggplot(gpp_sf_LMU_wide, 
                         aes(x = fct_rev(as.factor(inun)), 
                             y = logGPP, color = logGPP)) +
  geom_linerange(mapping = aes(ymin = lower_logGPP, ymax = upper_logGPP), color = 'grey50') +
  geom_point() + # the geom_bar equivalent when it's not counting cases.
  scale_color_stepsn(colors = gppControl$gpppal,
                     breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                     labels = gppControl$gpplabels,
                     guide = 'legend',
                     name = gpplabel) +
  scale_y_continuous(breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     labels = round(10^(gppControl$gppbreaks[2:length(gppControl$gppbreaks)]))) +
  labs(x = 'Inundation volume (Ml at max extent)', y = gpplabel)
bargppallpoint
```

This actually might look better if I plot it against inundation (or log
inundation) as a continuous variable. Well, but that just recapitulates
the multiplication, so pretty boring. I guess it shows that small
deviations are due to temp? Still, kind of lame.

```{r}
bargppallpointC <- ggplot(gpp_sf_LMU_wide, 
                         aes(x = logInun, 
                             y = logGPP, color = logGPP)) +
  geom_linerange(mapping = aes(ymin = lower_logGPP, ymax = upper_logGPP), color = 'grey50') +
  geom_point() + # the geom_bar equivalent when it's not counting cases.
  scale_color_stepsn(colors = gppControl$gpppal,
                     breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                     labels = gppControl$gpplabels,
                     guide = 'legend',
                     name = gpplabel) +
  scale_y_continuous(breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                     labels = round(10^(gppControl$gppbreaks[2:length(gppControl$gppbreaks)]))) +
  labs(x = 'log Inundation volume (Ml at max extent)', y = gpplabel)
bargppallpointC
```

### ER

Setup block. Again, this could be sorted with a function, but right now
just copy-pasting

```{r}
erlabel <- 'GPP (kg 02/day)\nat max extent'

er_sf_LMU_wide <- bind_cols(er_sf[,-4], 
                             st_drop_geometry(rename(er_sfPU[,-c(4)], 
                                                     UER = ER, 
                                                     upper_logER = logER)),
                             st_drop_geometry(rename(er_sfPL[,-4], 
                                                     LER = ER,
                                                     lower_logER = logER)),
                            st_drop_geometry(inun_sf)) %>%
  mutate(wetlandID = row_number())
```

Barplot

```{r}
barerall <- ggplot(er_sf_LMU_wide, 
                    aes(x = fct_rev(as.factor(inun)), 
                   y = logER, fill = logER)) +
  geom_col() + # the geom_bar equivalent when it's not counting cases.
  geom_linerange(mapping = aes(ymin = lower_logER, ymax = upper_logER),
                 color = 'grey50', alpha = 0.2) +
  scale_fill_stepsn(colors = erControl$erpal,
                    breaks = erControl$erbreaks[2:length(erControl$erbreaks)],
                    limits = c(min(erControl$erbreaks), max(erControl$erbreaks)),
                    labels = erControl$erlabels,
                    guide = 'legend',
                    name = erlabel) +
  scale_y_continuous(breaks = erControl$erbreaks[2:length(erControl$erbreaks)],
                     labels = round(10^(erControl$erbreaks[2:length(erControl$erbreaks)]))) +
  scale_x_discrete(breaks = as.character(xbreaks), labels = as.character(round(xbreaks))) +
  labs(x = 'Inundation volume (Ml at max extent)', y = erlabel)
barerall
```

### Both together, with GPP up and ER down

Setup

```{r}
# Can I make one with them both there going opposite direction?
both_sf_LMU_wide <- bind_cols(mutate(gpp_sf_LMU_wide), 
                              mutate(st_drop_geometry(er_sf_LMU_wide[,-(7:10)])))

# Need new labels and breaks. Could cobble, but getting confusing and misaligned
# bothbreaks_log <- c(-rev(erbreaks_log[2:length(erbreaks_log)]), gppbreaks_log)
 
# # and those breaks might not quite yield 10, so maximise the palette differences
# erpal_log <- sequential_hcl(length(erbreaks_log)-1, palette = 'Purples', rev = TRUE)
# I think here I want continuous colors. but maybe still a broken up legend?

# have to do the negatives before delogging
# bothlabels_log <- c(-10^rev(erbreaks_log), 10^gppbreaks_log)
# 
# bothlabels_log <- format(bothlabels_log, big.mark=",", 
                       # scientific=FALSE, trim = TRUE, digits = 0)

# This is really getting complex. Why don't I just use 0,1,10,100,1000,10000?
# They've both been shifted by 1 to log, so
# This is just used to get the labels, the actual log-scale is plotted and so the zeros are done correctly
bothbreaks_log <- c(-10^(4:0), 10^(1:4))
bothbreaks_log[5] <- 0 # Because both were shifted so 1 = 0
bothlabels_log <- as.character(bothbreaks_log)


# erstart <- erlabels_log[1:(length(erlabels_log)-1)]
# erstart[1] <- "0" # instead of 1
# bothlabels_log <- paste0(erstart, ' to ', erlabels_log[2:length(erlabels_log)])
# erlabels_log

# AAAA try to get some lables for the x. I JUST WANT IT TO HAVE THE NUMBER BUT IT WON"T DO IT
reordx <- fct_reorder(as.factor(both_sf_LMU_wide$wetlandID), 
                      both_sf_LMU_wide$logGPP, .desc = TRUE)
# I'm confused. that didn't work. this is anoyuting
```

Try a plot

```{r}
barbothQ <- ggplot(both_sf_LMU_wide) +
  geom_col(mapping = aes(x = fct_rev(as.factor(inun)), 
                         y = -logER, fill = -logER)) + # the geom_bar equivalent when it's not counting cases.
  geom_linerange(mapping = aes(x = fct_rev(as.factor(inun)),
                               ymin = -lower_logER, ymax = -upper_logER),
                 color = 'grey50', alpha = 0.2) +
  # scale_fill_stepsn(colors = erpal_log,
  #                   breaks = erbreaks_log[2:length(erbreaks_log)],
  #                   limits = c(min(erbreaks_log), max(erbreaks_log)),
  #                   labels = erlabels_log,
  #                   guide = 'legend',
  #                   name = erlabel) +
 
  # scale_fill_stepsn(colors = c(rev(erpal_log), gpppal_log),
  #            breaks = c(-rev(erbreaks_log[2:length(erbreaks_log)]), 0,
  #                       gppbreaks_log[2:length(gppbreaks_log)]),
  #            limits = c(min(-erbreaks_log), max(gppbreaks_log)),
  #            # labels = c(erlabels_log, gpplabels_log),
  #            guide = 'legend',
  #            name = 'kg O2\nat max extent') +
  geom_col(mapping = aes(x = fct_rev(as.factor(inun)), 
                         y = logGPP, fill = logGPP)) +
  geom_linerange(mapping = aes(x = fct_rev(as.factor(inun)),
                               ymin = lower_logGPP, ymax = upper_logGPP),
                 color = 'grey50', alpha = 0.2) +
  geom_line(mapping = aes(x = fct_rev(as.factor(inun)), 
                           y = logGPP-logER, group = NA)) +
  
  # This palette is very slightly different because it's not binned and GPP above uses Emerald instead of green, but it's sure close and way easier
  scale_fill_continuous_diverging(palette = "Purple-Green",
                                  limits = c(-4, 4), 
                                  breaks = -4:4,
                                  labels = bothlabels_log) +
  scale_y_continuous(limits = c(-4, 4),
                     breaks = -4:4,
                     labels = bothlabels_log) +
  # scale_y_continuous(breaks = c(-erbreaks_log[2:length(erbreaks_log)], 
  #                               gppbreaks_log[2:length(gppbreaks_log)]),
  #                    labels = c(-round(10^(erbreaks_log[2:length(erbreaks_log)])), 
  #                               round(10^(gppbreaks_log[2:length(gppbreaks_log)])))) +
  labs(x = 'Inundation volume (Ml at max extent)', y = 'kg O2', fill = 'kg O2') +
  # argh doesn't work because has been reordered
  scale_x_discrete(breaks = as.character(xbreaks), labels = as.character(round(xbreaks))) +
  theme_pub()  + theme(legend.position = c(0.75, 0.53),
                                  panel.grid.major = element_blank(),
                                  panel.grid.minor = element_blank())
barbothQ
```

The ranked x might make more sense? Easier to read, anyway.

```{r}
both_sf_LMU_wide2 <- both_sf_LMU_wide %>% 
  arrange(desc(inun)) %>% 
  mutate(inunrank = row_number())
```

Make the plot. Interesting that the notebook plotter does a worse job
than the plots panel for a script. The funny gaps aren't really there-
to see, run barboth in the console.

```{r}
barboth <- ggplot(both_sf_LMU_wide2) +
  geom_col(mapping = aes(x = inunrank, 
                         y = -logER, fill = -logER)) + # the geom_bar equivalent when it's not counting cases.
  geom_linerange(mapping = aes(x = inunrank,
                               ymin = -lower_logER, ymax = -upper_logER),
                 color = 'grey50', alpha = 0.2) +

geom_col(mapping = aes(x = inunrank, 
                       y = logGPP, fill = logGPP)) +
  geom_linerange(mapping = aes(x = inunrank,
                               ymin = lower_logGPP, ymax = upper_logGPP),
                 color = 'grey50', alpha = 0.2) +
  geom_line(mapping = aes(x = inunrank, 
                          y = logGPP-logER, group = NA)) +
  
  # This palette is very slightly different because it's not binned and GPP above uses Emerald instead of green, but it's sure close and way easier
  scale_fill_continuous_diverging(palette = "Purple-Green",
                                  limits = c(-4, 4), 
                                  breaks = -4:4,
                                  labels = bothlabels_log) +
  scale_y_continuous(limits = c(-4, 4),
                     breaks = -4:4,
                     labels = bothlabels_log) +
  labs(x = 'Ranked inundation', y = 'kg O2', fill = 'kg O2') +
  # scale_x_discrete(breaks = c(1, 250, 500, 750, 1000)) +
  theme_pub()  + theme(legend.position = c(0.75, 0.53),
                                  panel.grid.major = element_blank(),
                                  panel.grid.minor = element_blank())
barboth
```

Save those as figures

```{r}

pdf(file.path(scriptOut, 'Werai_mirrorgramQ.pdf'), 
    onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
print(barbothQ)
dev.off()

png(file.path(scriptOut, 'Werai_mirrorgramQ.png'), 
    height = 12/2.54, width = 16/2.54, units = 'in', res = 300)
print(barbothQ)
dev.off()


pdf(file.path(scriptOut, 'Werai_mirrorgram.pdf'), 
    onefile = FALSE, height = 8/2.54, width = 12/2.54, useDingbats = FALSE)
print(barboth)
dev.off()

png(file.path(scriptOut, 'Werai_mirrorgram.png'), 
    height = 8/2.54, width = 12/2.54, units = 'in', res = 300)
print(barboth)
dev.off()
```

What about Darren's fingerprints? They would maybe take the GPP and ER
and make a density with them? OUt of what? The wetlands? Could work.
Would need to sort out the weighting by volume. it's already in there,
but that means it will give each location the same weight. I think a
better thing for the fingerprints would be to remove it, and then give
each wetland its predicted per liter rate and weight by volume IE use
the straight predictions and then weight by inundaton Should be
straightforward, but likely won't be

Would be a really cool way to look at scenarios. especially if I can do
it for whole catchments

BUT, because GPP and ER are both linear fits of temp, they will exactly
predict each other according to a linear relationship, and so there
won't be any 2-d variation and all the points will fall on a line. IE
for a given GPP there will only be one ER, and so the fingerprint will
be a line. Cool idea, but we'd need more info about their variance
relative to each other

## Annual reporting

What about making some examples to illustrate annual (or arbitrary time
period) reporting?

First, establish the time periods and do the aggregations and other data
organisation.

USE MAX ACROSS TIME FOR THE BIMONTHLY MAX EXTENTS- THAT GIVES A YEARLY
MAX SINCE THE MEAN IS MEANINGLESS

This is all done in the metabPlotSetup_Local.

```{r}

# I THINK I SHOULD BE ABLE TO SKIP THIS and use the functions. BUT not time right now to switch
# GPP
gppYear_sf <- gppannual %>% 
  st_as_sf() %>% 
  pivot_longer(cols = -geometry, names_to = 'WaterYear', values_to = 'GPP') %>%
  mutate(logGPP =  log10(1+GPP)) %>%
  st_as_sf() # REALLY???
gppYear_sf

max(gppYear_sf$logGPP) # is within 
gppControl$gppbreaks

# ER
erYear_sf <- erannual %>% 
  st_as_sf() %>% 
  pivot_longer(cols = -geometry, names_to = 'WaterYear', values_to = 'ER') %>%
  mutate(logER =  log10(1+ER)) %>%
  st_as_sf() # REALLY???
erYear_sf

# the range should still work for tthe colors
max(erYear_sf$logER) # is within 
erControl$erbreaks

# Temp
tempYear_sf <- tempannual %>% 
  st_as_sf() %>% 
  pivot_longer(cols = -geometry, names_to = 'WaterYear', values_to = names(tempannual)) %>%
  st_as_sf() # REALLY???


# Inundation
inunYear_sf <- inunannual %>% 
  st_as_sf() %>% 
  pivot_longer(cols = -geometry, names_to = 'WaterYear', values_to = names(inunannual)) %>%
  mutate(logInun =  log10(1+volumeML)) %>%
  st_as_sf() # REALLY???

```

I don't think I use this, but I did make a full-werai aggregation. SUM
across space is fine.

```{r}
# aggregate to werai
# temp area-weighted
areas <- tempannual %>%
  st_geometry() %>%
  st_area() %>%
  as.numeric()
tempW <- catchAgg <- catchAggW(strict = tempannual, strictWeights = areas,
                               FUN = mean, summaryPoly = ramsarW1)
  # sum across space
inunW <- aggregate(inunannual, 
                      by = ramsarW1, 
                      FUN = sum, na.rm = TRUE)

gppW <- aggregate(gppannual, 
                   by = ramsarW1, 
                   FUN = sum, na.rm = TRUE)
erW <- aggregate(erannual, 
                   by = ramsarW1, 
                   FUN = sum, na.rm = TRUE)

```

### Tmap Plots

Make a facetted tmap

Again, can I do this by modifying what I pass to the plotting functions?
Almost certainly

The units are weird, because this is added up across bimonths. It's
neither the total or the average.Not really sure what to call it

Change the tmap_mode() depending on the purpose. DO NOT CHANGE TO VIEW
AND TRY TO RUN HERE. IF YOU WANT TO VIEW, CHANGE AND RUN IN CONSOLE. The
markdown will run it, but incredibly slowly.

#### GPP

```{r}
tmap_mode('plot')

gppyrlabel <- 'Yearly GPP maximum\n(kg 02)'

  gppAnnual_tm <- gppYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    tm_shape() +
    tm_fill(col = 'logGPP',
            palette = gppControl$gpppal,
            breaks = gppControl$gppbreaks,
            labels = gppControl$gpplabels,
            title = gppyrlabel) + 
    tm_facets(by = 'WaterYear')
  gppAnnual_tm
```

#### ER

```{r}
eryrlabel <- 'Yearly ER maximum\n(kg 02)'
  
  erAnnual_tm <- erYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    tm_shape() +
    tm_fill(col = 'logER',
            palette = erControl$erpal,
            breaks = erControl$erbreaks,
            labels = erControl$erlabels,
            title = eryrlabel) + 
    tm_facets(by = 'WaterYear')
  erAnnual_tm
```

### GGPLOT

#### gpp

```{r}
gppAnnual_gg <- gppYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    ggplot() +
    geom_sf(mapping = aes(fill = logGPP), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = gppControl$gpppal,
                      breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                      limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                      labels = gppControl$gpplabels,
                      guide = 'legend',
                      name = gppyrlabel) +
    facet_wrap(vars(WaterYear))
  gppAnnual_gg
```

#### ER

```{r}
erAnnual_gg <- erYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    ggplot() +
    geom_sf(mapping = aes(fill = logER), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = erControl$erpal,
                      breaks = erControl$erbreaks[2:length(erControl$erbreaks)],
                      limits = c(min(erControl$erbreaks), max(erControl$erbreaks)),
                      labels = erControl$erlabels,
                      guide = 'legend',
                      name = eryrlabel) +
    facet_wrap(vars(WaterYear))
  erAnnual_gg
```

What do the drivers look like for those years?

#### Temp

```{r}
tempyrlabel <- 'Yearly mean\ntemp (C)'

tempControl <- tempsetup(data = weraiCropTemp, attnum = 1)
tempAnnual_gg <- tempYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    ggplot() +
    geom_sf(mapping = aes(fill = bimonth_tempC), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = tempControl$temppal,
                      breaks = tempControl$tempbreaks[2:length(tempControl$tempbreaks)],
                      limits = c(min(tempControl$tempbreaks), max(tempControl$tempbreaks)),
                      labels = tempControl$templabels,
                      guide = 'legend',
                      name = tempyrlabel) +
    facet_wrap(vars(WaterYear))
 tempAnnual_gg
```

#### Inundation

```{r}
inunyrlabel <- 'Yearly inundation\nmaximum (ML)'

inunControl <- inunsetup(data = weraiCropInun, attnum = 1)
inunAnnual_gg <- inunYear_sf %>%
    filter(WaterYear != '2014-06-29') %>% # because a 5-panel is ugly
    ggplot() +
    geom_sf(mapping = aes(fill = volumeML), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = inunControl$inunpal,
                      breaks = inunControl$inunbreaks[2:length(inunControl$inunbreaks)],
                      limits = c(min(inunControl$inunbreaks), max(inunControl$inunbreaks)),
                      labels = inunControl$inunlabels,
                      guide = 'legend',
                      name = inunyrlabel) +
    facet_wrap(vars(WaterYear))
 inunAnnual_gg
```

Stack 3 years of gpp and ER together for the document

```{r}
gppAnnual_gg3 <- gppYear_sf %>%
    filter(WaterYear != '2014-06-29' & WaterYear != '2018-06-29') %>% # because a 5-panel is ugly
  mutate(WaterYear = str_remove(WaterYear, '-06-29')) %>% # because these are water years, don't clutter up wit months
    ggplot() +
    geom_sf(mapping = aes(fill = logGPP), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = gppControl$gpppal,
                      breaks = gppControl$gppbreaks[2:length(gppControl$gppbreaks)],
                      limits = c(min(gppControl$gppbreaks), max(gppControl$gppbreaks)),
                      labels = gppControl$gpplabels,
                      guide = 'legend',
                      name = gppyrlabel) +
    facet_grid(WaterYear~.) + 
    theme_pub(legend.position = 'bottom')
  # gppAnnual_gg3 
  
  erAnnual_gg3 <- erYear_sf %>%
    filter(WaterYear != '2014-06-29' & WaterYear != '2018-06-29') %>% # because a 5-panel is ugly
      mutate(WaterYear = str_remove(WaterYear, '-06-29')) %>% # because these are water years, don't clutter up wit months
    ggplot() +
    geom_sf(mapping = aes(fill = logER), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = erControl$erpal,
                      breaks = erControl$erbreaks[2:length(erControl$erbreaks)],
                      limits = c(min(erControl$erbreaks), max(erControl$erbreaks)),
                      labels = erControl$erlabels,
                      guide = 'legend',
                      name = eryrlabel) +
    facet_grid(WaterYear~.) + 
    theme_pub(legend.position = 'bottom')
  # erAnnual_gg3

  annualGPPER <- ggpubr::ggarrange(gppAnnual_gg3 + 
                                     guides(fill = guide_legend(title.position = 'top')) +
                                     theme_pub() +
                                     theme(legend.position = 'bottom', 
                                           legend.background = element_blank(),
                                           legend.key.size = unit(0.3, 'cm')), 
                    erAnnual_gg3 + 
                      guides(fill = guide_legend(title.position = 'top')) +
                      theme_pub() +
                      theme(legend.position = 'bottom', 
                            legend.background = element_blank(),
                            legend.key.size = unit(0.3, 'cm')),
                    ncol = 2, nrow = 1)
  annualGPPER
```

Print out the ggplots for the doc

```{r}
 # Just print the ggplots
  # Can I print those?
  pdf(file.path(scriptOut, 'Werai_gg_Annual.pdf'), 
      onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
  print(annualGPPER)
  dev.off()
  
  png(file.path(scriptOut, 'Werai_gg_Annual.png'), 
      height = 12/2.54, width = 16/2.54, units = 'in', res = 300, type = 'cairo')
  print(annualGPPER)
  dev.off()
  

```

Same, but for the drivers (to go in appendix, probably)

```{r}
tempAnnual_gg3 <- tempYear_sf %>%
    filter(WaterYear != '2014-06-29' & WaterYear != '2018-06-29') %>% # because a 5-panel is ugly
  mutate(WaterYear = str_remove(WaterYear, '-06-29')) %>% # because these are water years, don't clutter up wit months
    ggplot() +
    geom_sf(mapping = aes(fill = bimonth_tempC), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = tempControl$temppal,
                      breaks = tempControl$tempbreaks[2:length(tempControl$tempbreaks)],
                      limits = c(min(tempControl$tempbreaks), max(tempControl$tempbreaks)),
                      labels = tempControl$templabels,
                      guide = 'legend',
                      name = tempyrlabel) +
    facet_grid(WaterYear~.) + 
    theme_pub(legend.position = 'bottom')

  inunAnnual_gg3 <- inunYear_sf %>%
    filter(WaterYear != '2014-06-29' & WaterYear != '2018-06-29') %>% # because a 5-panel is ugly
  mutate(WaterYear = str_remove(WaterYear, '-06-29')) %>% # because these are water years, don't clutter up wit months
    ggplot() +
    geom_sf(mapping = aes(fill = logInun), color = NA) +
    coord_sf() +
    # Closest to the tmap
    scale_fill_stepsn(colors = inunControl$inunpal,
                      breaks = inunControl$inunbreaks[2:length(inunControl$inunbreaks)],
                      limits = c(min(inunControl$inunbreaks), max(inunControl$inunbreaks)),
                      labels = inunControl$inunlabels,
                      guide = 'legend',
                      name = inunyrlabel) +
    facet_grid(WaterYear~.) + 
    theme_pub(legend.position = 'bottom')
  
  
  annualTI <- ggpubr::ggarrange(tempAnnual_gg3 + 
                                     guides(fill = guide_legend(title.position = 'top')) +
                                     theme_pub() +
                                     theme(legend.position = 'bottom', 
                                           legend.background = element_blank(),
                                           legend.key.size = unit(0.3, 'cm')), 
                    inunAnnual_gg3 + 
                      guides(fill = guide_legend(title.position = 'top')) +
                      theme_pub() +
                      theme(legend.position = 'bottom', 
                            legend.background = element_blank(),
                            legend.key.size = unit(0.3, 'cm')),
                    ncol = 2, nrow = 1)
  annualTI
```

Print out the ggplots for the doc

```{r}
 # Just print the ggplots
  # Can I print those?
  pdf(file.path(scriptOut, 'Werai_gg_Annual_DRIVERS.pdf'), 
      onefile = FALSE, height = 12/2.54, width = 16/2.54, useDingbats = FALSE)
  print(annualTI)
  dev.off()
  
  png(file.path(scriptOut, 'Werai_gg_Annual_DRIVERS.png'), 
      height = 12/2.54, width = 16/2.54, units = 'in', res = 300)
  print(annualTI)
  dev.off()
  

```

## Scenarios

Want to base this pretty closely on the basin-scale scenarios. But it
would be nice if I came up with some plots that actually measure the
change, too. Maybe just change from baseline? ie scene x - baseline? On
absolute or relative scale? as maps? As barplots with baseline \@ 0?

Make all the plots. Ah, but the basin-scale (where this is sorted out)
uses annual stars created in the setup file, while here I've used
xxxYear_sf created in this rmd.The way I do it for the basin is better,
but do I have the memory to do it that way here, or will I need to
delete all the Years_sf objects and change how all that is done?

Well, wait. I already have erannual and gppannual and inunannual and
tempannual here as stars. so I think I don't need to go wholly remake
things. Instead, how do I get to those (and why didn't I use them
above???- I then go make the sfs with them, but that's what gets made
inside the plotting functions, so not sure why I needed them.

*scaling that works for all years fails to show what's happenign because
years are so different*

```{r}
yrwanted <- '2016-06-29'

# Sort out the scales
yrdex <- which(st_get_dimension_values(tempannual, which = 'time') == yrwanted)

tempannual[,,yrdex]
climannual[,,yrdex]

inunannual[,,yrdex]
inun10pannual[,,yrdex]

# Need to capture the endmembers
gppannual[1,,yrdex]
gppannual10p_clim[,,yrdex]

erannual[1,,yrdex]
erannual10p_clim[,,yrdex]

# This is hacky, but I'm going to just force those

tempmin <- 25
tempmax <- 35

inunmin <- 0
inunmax <- 2500

gppmin <- 500
gppmax <- 2500

ermin <- 500
ermax <- 5500


```

### GPP

```{r}

gppBase <- gppfun(gppannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = gppmin, forcemax = gppmax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gppBase

gppClim <- gppfun(gppannual_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = gppmin, forcemax = gppmax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gppClim

gpp10p <- gppfun(gppannual10p, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = gppmin, forcemax = gppmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gpp10p

gpp10p_clim <- gppfun(gppannual10p_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = gppmin, forcemax = gppmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gpp10p_clim
```

### ER

```{r}
erBase <- erfun(erannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = ermin, forcemax = ermax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# erBase

erClim <- erfun(erannual_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = ermin, forcemax = ermax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# erClim

er10p <- erfun(erannual10p, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = ermin, forcemax = ermax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# er10p

er10p_clim <- erfun(erannual10p_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = ermin, forcemax = ermax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# er10p_clim
```

### Inputs

```{r}

tempyr <- tempfun(tempannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 forcemin = tempmin, forcemax = tempmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# tempyr

climyr <- tempfun(climannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 forcemin = tempmin, forcemax = tempmax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# climyr

inunyr <- inunfun(inunannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = inunmin, forcemax = inunmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# inunyr

inun10pyr <- inunfun(inun10pannual, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = inunmin, forcemax = inunmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# inun10pyr
```

### Make the plots

```{r}
gppScene <- plot_spacer() +
(tempyr + ggtitle('Baseline temperature') + theme(legend.position = 'none')) +
  (climyr + ggtitle('2c warming') + theme(legend.position = 'none')) +
  
  (inunyr + ggtitle('Baseline inundation') + theme(legend.position = 'none')) +
(gppBase + theme(legend.position = 'none')) + # + ggtitle('Baseline') 
  (gppClim + theme(legend.position = 'none')) + #  + ggtitle('2c warming')
  
  (inun10pyr + ggtitle('110% inundation') + theme(legend.position = 'none')) +
  (gpp10p + theme(legend.position = 'none')) + # + ggtitle('110% inundation') 
  (gpp10p_clim + theme(legend.position = 'none')) + # + ggtitle('2c & 110%')
  plot_layout(nrow = 3)
gppScene
```

```{r}
pdf(file.path(scriptOut, 'gppScene.pdf'), 
    onefile = FALSE, height = 16/2.54, width = 16/2.54, useDingbats = FALSE)
print(gppScene)
dev.off()

png(file.path(scriptOut, 'gppScene.png'), 
    height = 16/2.54, width = 16/2.54, units = 'in', res = 300, type = 'cairo')
print(gppScene)
dev.off()
```

Same, with ER

```{r}
erScene <- plot_spacer() +
(tempyr + ggtitle('Baseline temperature') + theme(legend.position = 'none')) +
  (climyr + ggtitle('2c warming') + theme(legend.position = 'none')) +
  
  (inunyr + ggtitle('Baseline inundation') + theme(legend.position = 'none')) +
(erBase + theme(legend.position = 'none')) + # + ggtitle('Baseline') 
  (erClim + theme(legend.position = 'none')) + #  + ggtitle('2c warming')
  
  (inun10pyr + ggtitle('110% inundation') + theme(legend.position = 'none')) +
  (er10p + theme(legend.position = 'none')) + # + ggtitle('110% inundation') 
  (er10p_clim + theme(legend.position = 'none')) + # + ggtitle('2c & 110%')
  plot_layout(nrow = 3)
erScene
```

```{r}
pdf(file.path(scriptOut, 'erScene.pdf'), 
    onefile = FALSE, height = 16/2.54, width = 16/2.54, useDingbats = FALSE)
print(erScene)
dev.off()

png(file.path(scriptOut, 'erScene.png'), 
    height = 16/2.54, width = 16/2.54, units = 'in', res = 300)
print(erScene)
dev.off()
```

The issue here is that the changes with scenario are small relative to
the variation in space, so they don't pick up differences between
scenarios very well. Can we zoom in on a few polygons?

### zoom in

Same gpp as above, but clipped.

Where to clip? Just hunt around with the indices, I think.

```{r}
ggplot() +
  geom_stars(data = gppannual[1,,1], mapping = aes(fill = predicted_GPP_kg02perday_at_max_inun)) +
  geom_stars(data = gppannual[1,600:700,1], fill = 'white')
```

Create the clipped data- we'll need this for setting consistent min and
max.

I can't get anything to show up using the raw data. use the difference?

```{r}
clipset <- 1:1163

gppannclip <- gppannual[1, clipset, ]
gppannclip_clim <- gppannual_clim[1, clipset, ]

gppannclip10p <- gppannual10p[1, clipset, ]
gppannclip10p_clim <- gppannual10p_clim[1, clipset, ]

refclip <- gppannclip[[1]]
gppannclip[[1]] <- gppannclip[[1]] - refclip
gppannclip_clim[[1]] <- gppannclip_clim[[1]] - refclip
gppannclip10p[[1]] <- gppannclip10p[[1]] - refclip
gppannclip10p_clim[[1]] <- gppannclip10p_clim[[1]] - refclip

whichyr <- which(st_get_dimension_values(gppannclip, which = 'time') == yrwanted)

clipmin <- min(gppannclip[1,,whichyr]$predicted_GPP_kg02perday_at_max_inun)
clipmax <- max(gppannclip10p_clim[1,,whichyr]$predict_x_vol10p_GPPdaysvalleys) + 1


# What are the values?
max(gppannclip[1,,whichyr]$predicted_GPP_kg02perday_at_max_inun)
max(gppannclip_clim[1,,whichyr]$predicted_GPP_kg02perday_at_max_inun)
max(gppannclip10p[1,,whichyr]$predict_x_vol10p_GPPdaysvalleys)
max(gppannclip10p_clim[1,,whichyr]$predict_x_vol10p_GPPdaysvalleys)




gppBaseC <- gppfun(gppannclip, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = clipmin, forcemax = clipmax,
                 forcelegend = 'Change in GPP from baseline\n (kg O2/day)')  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gppBase

gppClimC <- gppfun(gppannclip_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = clipmin, forcemax = clipmax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gppClim

gpp10pC <- gppfun(gppannclip10p, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = clipmin, forcemax = clipmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# gpp10p

gpp10p_climC <- gppfun(gppannclip10p_clim, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = clipmin, forcemax = clipmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

```

Got that mostly working- now need to also re-make tempyr, climyr, etc.
Do I want to clip them as well, or just do the zoom?

Try clipping first. I think I probably do need to adjust inundation to.

```{r}
tempclip <- tempannual[1,clipset, ]
climclip <- climannual[1, clipset, ]

inunclip <- inunannual[1,clipset, ]
refinun <- inunclip
inunclip <- inunclip - refinun

inun10pclip <- inun10pannual[1,clipset,]
inun10pclip <- inun10pclip - refinun

inmin <- min(inunclip[1,,whichyr]$volumeML)
inmax <- max(inun10pclip[1,,whichyr]$volumeML) + 1


tempyrC <- tempfun(tempclip, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 forcemin = tempmin, forcemax = tempmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# tempyr

climyrC <- tempfun(climclip, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 forcemin = tempmin, forcemax = tempmax)  +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# climyr

inunyrC <- inunfun(inunclip, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = inmin, forcemax = inmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

# inunyr

inun10pyrC <- inunfun(inun10pclip, 1, 
                 datewanted = yrwanted,
                 # units = 'tonnes', 
                 plotPkg = 'ggplot', 
                 titled = FALSE,  
                 colorchoice = NA,
                 logscale = FALSE, 
                 forcemin = inmin, forcemax = inmax) +
  theme_pub() +
  theme(legend.position = 'right', 
       legend.background = element_blank(),
       legend.key.size = unit(0.3, 'cm'))

```

```{r}
gppSceneC <- guide_area() +
(tempyrC + 
   ggtitle('Baseline temperature') + 
   scale_x_continuous(breaks = c(144, 144.3, 144.6)) +
   theme(legend.position = 'none')) +
  (climyrC + 
     ggtitle('2c warming') + 
     scale_x_continuous(breaks = c(144, 144.3, 144.6)) + 
     theme(legend.position = 'none')) +
  
  (inunyrC + 
     ggtitle('Baseline inundation') +
     scale_x_continuous(breaks = c(144, 144.3, 144.6)) + 
     theme(legend.position = 'none')) +
(gppBaseC + scale_x_continuous(breaks = c(144, 144.3, 144.6))) +
  (gppClimC + 
     scale_x_continuous(breaks = c(144, 144.3, 144.6)) +
     theme(legend.position = 'none')) + #  + ggtitle('2c warming')
  
  (inun10pyrC + 
     ggtitle('110% inundation') +
     scale_x_continuous(breaks = c(144, 144.3, 144.6)) +
     theme(legend.position = 'none')) +
  (gpp10pC + scale_x_continuous(breaks = c(144, 144.3, 144.6)) +
   theme(legend.position = 'none')) + # + ggtitle('110% inundation') 
  (gpp10p_climC + scale_x_continuous(breaks = c(144, 144.3, 144.6)) +
   theme(legend.position = 'none')) + # + ggtitle('2c & 110%')
  plot_layout(nrow = 3, guides = 'collect')
gppSceneC
```

Print that out

```{r}
pdf(file.path(scriptOut, 'gppSceneDiff.pdf'), 
    onefile = FALSE, height = 16/2.54, width = 16/2.54, useDingbats = FALSE)
print(gppSceneC)
dev.off()

png(file.path(scriptOut, 'gppSceneDiff.png'), 
    height = 16/2.54, width = 16/2.54, units = 'in', res = 300, type = 'cairo')
print(gppSceneC)
dev.off()
```
