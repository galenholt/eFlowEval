---
title: "Local_Inundation"
author: "Galen"
format: html
editor: visual
---

## Local runs of inundation

This could really be cleaned up even quite a bit more- it really just only takes a couple args and could be a function. And possibly wrapped in a while (!is.null(runlist)) (though that's dangerous)- see the post-processing at the end.

### Setup

```{r}
# Yeesh, pull these out
library(here)
library(tidyverse)
library(sf)
library(stars)
library(foreach)
library(doFuture)
library(doRNG)
```

First, set directories and read-in function

```{r}
source('directorySet.R')

registerDoFuture()

plan(multisession) # I *think* sequential allows debug?
```

### Check what needs to happen

```{r}
# I've modified makeSHfails to give me a list
runlist <- makeSHfails(outerDir = file.path(datOut, 'Inundationprocessed'),
            summaryFuns = 'lippiaAdultSurvive',
            varName = 'LippiaSurvive',
            nchunks = 100,
            lengthOrChunk = c('short', 'long'), # , 'long', 'chunk'
            runImmediate = FALSE,
            forceAllCatchments = TRUE,
            returnForR = TRUE)
```

```{r}
runlist
```

## Set up the runs

```{r}
#| messages: false
#| warning: false
# Run over the catchments and chunks 
alltimes <- foreach(w = names(runlist), 
                    .combine = rbind, 
                    .errorhandling = 'remove') %:%
  foreach(i = as.character(runlist[[w]]), 
          .combine = rbind, 
          .errorhandling = 'remove') %dopar% {
            inuntab <- processData(dataname = 'inundation', 
                                   data_dir = datDir, 
                                   summaryFun = 'lippiaAdultSurvive', 
                                   out_dir = datOut, 
                                   catchment = w, 
                                   thischunk = i)
            
            inuntab
          }
```

### Timings

The timings are saved in alltimes

```{r}
alltimes
```

## Concatenate

**TODO- make this automatic (a function?)**- I should be able to run \`makeSHfails\` here, then if there are no fails, immediately run `concatANAEchunks`. Could wrap the whole script in a `while(!is.null(runlist))`, but that's dangerous.

```{r}
runlist_end <- makeSHfails(outerDir = file.path(datOut, 'Inundationprocessed'),
                       summaryFuns = 'lippiaAdultSurvive',
                       varName = 'LippiaSurvive',
                       nchunks = 100,
                       lengthOrChunk = c('short', 'long'), # , 'long', 'chunk'
                       runImmediate = FALSE,
                       forceAllCatchments = TRUE,
                       returnForR = TRUE)

if (is.null(runlist_end)) {
  cattime <- system.time(concatANAEchunks(
    outerDir = file.path(datOut,
                         'Inundationprocessed'),
    summaryFuns = c('lippiaAdultSurvive')))
  print(cattime)
}


```

     user  system elapsed 
      91.36   61.53 1479.17 

### Check the anaes aren't weirdly duplicated

```{r}
check_aggs <- test_anae_agg(catchments = NULL, datDir = datOut, variableDir = 'Inundationprocessed', summaryFun = 'lippiaAdultSurvive', forceAllCatchments = TRUE)
```

```{r}
check_aggs
```

This should yield 0 rows unless there are unexpected errors and warnings.

```{r}
check_aggs %>% filter(passfail != 'pass' & !grepl('duplicates are failing', passfail))
```
